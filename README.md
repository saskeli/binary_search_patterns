# Binary search patterns

Testing a few binary search-based implementation on static sorted  data.

### binary search

Straight up classical binary search, with the implied inefficient memory access pattern.

Is generally faster than expected.

### B-star tree

A B-tree is built based on the data. Branch selection in internal nodes is done with a templated power-of-2 -based binary search.

Is pretty ok but very space inefficient and loses comparative perofmance as the data structure size grows.

### Heap ordered binary search

Input data is "reordered" in such a way that the middle element is first, then the middle of the left and right sides, followed by the middles of the left and right portions of the left side and so on. For each "node" at index `i`, the left child is at `i * 2 + 1` and the right child is a t `i * 2 + 2`

Uses up to double the space of the raw data due to the data not necessarily conforming to the linearized tree topology.

Is typically the fastest of the approaches as long as the input data is large enough.

### B-heap tree

Combination of B-star tree and Heap ordered binary search. The B-tree nodes are stored in heap order. No child offsets or pointers are stored since children of a node at index `i` will be between indexes `i*B + 1` and `i*B + B`.

Seems to be very space efficient and fast.

## Usage

Compile with `make binary_search_patterns`.

Generate test data with 

```bash
python gen_data.py n m > file
```

where `n` is the size of the data structure, `m` the number of queries to generate and `file` an output file.

Run with

```bash
./binary_search_patterns type < file >> /dev/null
```

where `file` is a file generated by `gen_data.py` and `type` is

* 0 (or ommitted) to run queries interlieved on all the data structures at the same time,
* 1 to force cache invalidation between every query (**Caution: Very slow!)**,
* 2 to test each data structure separately.

Pipe data to ´/dev/null´ to avoid creating large tsv files with query data. If you want the per-query data, pipe somewhere else.

## Results

### AMD EPYC 7452, 10 million elements

|             | b-star    |heap       | binary   |
|-------------|-----------|-----------|----------|
| interlieved | 512.926ns | 471.164ns | 733.06ns |
| separate    | 456.826ns | 383.962ns | 534.394ns|
| space       | 157.511MB | 128MB     | 76.294MB |

### Intel(R) Xeon(R) CPU E7-8890 v4, 10 million elements

|             | b-star    |heap       | binary   |
|-------------|-----------|-----------|----------|
| interlieved | 436.847ns | 512.116ns | 673.536ns|
| separate    | 366.199ns | 414.743ns | 532.118ns|
| space       | 157.511MB | 128MB     | 76.294MB |

### Intel(R) Core(TM) i5-6200U

#### 10 million elements

|             | b-star    |heap       | binary    | b-heap    |
|-------------|-----------|-----------|-----------|-----------|
| interlieved | 561.28ns  | 498.914ns | 716.946ns | 441.875ns |
| separate    | 466.803ns | 486.74ns  | 597.929ns | 342.764ns |
| space       | 157.511MB | 128MB     | 76.294MB  | 78.3257MB |


\* All data-structure data was cleared from CPU cachess between queries

#### 2<sup>22</sup> elements

|             | b-star    |heap       | binary   |
|-------------|-----------|-----------|----------|
| interlieved | 450.327ns | 408.321ns | 695.112ns|
| separate    | 409.818ns | 375.593ns | 668.882ns|
| space       | 66.065MB  | 64MB      | 32MB     |

#### 2<sup>20</sup> elements

|             | b-star    |heap       | binary   |
|-------------|-----------|-----------|----------|
| interlieved | 351.858ns | 343.38ns  | 525.796ns|
| separate    | 293.726ns | 299.2ns   | 512.58ns |
| space       | 16.5161MB | 16MB      | 8.00002MB|

#### 100k elements

|             | b-star    |heap       | binary    |
|-------------|-----------|-----------|-----------|
| interlieved | 214.406ns | 233.02ns  | 214.157ns |
| separate    | 170.457ns | 205.57ns  | 198.599ns |
| space       | 1.57619MB | 2MB       | 0.762955MB|


